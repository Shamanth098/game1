<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Chess — Single Player</title>
<style>
  :root{
    --bg: linear-gradient(180deg,#e9f0ff,#f7fbff);
    --panel:#fff;
    --accent:#01091c;
    --square:64px;
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;color:#0b1220;background:var(--bg)}
  .wrap{max-width:980px;margin:20px auto;padding:14px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
  h1{margin:0;font-size:18px}
  .controls{display:flex;gap:8px;align-items:center}
  select,button{padding:8px 12px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);font-weight:700;cursor:pointer}
  .btn-primary{background:linear-gradient(90deg,var(--accent),#020d32);color:#fff;border:none}
  .layout{display:flex;gap:16px;align-items:flex-start}
  .board-wrap{background:var(--panel);padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.06)}
  #board{display:grid;grid-template-columns:repeat(8,var(--square));grid-auto-rows:var(--square);gap:4px;touch-action:none;user-select:none}
  .square{width:var(--square);height:var(--square);display:flex;align-items:center;justify-content:center;font-size:28px;border-radius:6px;position:relative;cursor:pointer;transition:transform .12s,box-shadow .12s}
  .light{background:#f3f6ff}
  .dark{background:#125e89}
  .highlight{outline:4px solid rgba(3, 14, 36, 0.22);transform:translateY(-4px);box-shadow:0 10px 30px rgba(37,99,235,0.08)}
  .last-move{box-shadow:inset 0 -6px rgba(0,0,0,0.06);outline:3px solid rgba(0,0,0,0.06)}
  .floating-piece{position:fixed;z-index:9999;pointer-events:none;font-size:28px;will-change:left,top,transform;transition:all .36s cubic-bezier(.2,.9,.3,1)}
  .panel{background:var(--panel);padding:12px;border-radius:10px;min-width:260px;box-shadow:0 10px 30px rgba(2,6,23,0.06)}
  .row{display:flex;justify-content:space-between;align-items:center;margin:8px 0}
  .muted{color:#010814;font-size:13px}
  .popup{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:9999}
  .popup .panel{max-width:360px;text-align:center}
  @media (max-width:920px){:root{--square:48px}.layout{flex-direction:column;align-items:center}.panel{width:100%}}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>♟ Chess — Single Player</h1>
      <div class="controls">
        <a href="chess.html" style="text-decoration:none"><button>← Chess Menu</button></a>
        <select id="difficulty"><option value="1">Easy</option><option value="2" selected>Normal</option><option value="3">Hard</option></select>
        <button id="startBtn" class="btn-primary">Start Game</button>
      </div>
    </header>

    <div class="layout">
      <div class="board-wrap">
        <div id="board" aria-label="Chess board"></div>
      </div>

      <aside class="panel">
        <div class="row"><div class="muted">Turn</div><div id="turnLabel">White</div></div>
        <div class="row"><div class="muted">Status</div><div id="statusLabel">Idle</div></div>
        <div style="height:8px"></div>
        <div class="muted">Controls</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="undoBtn">Undo</button>
          <button id="resetBtn">Reset</button>
        </div>
        <div style="height:12px"></div>
        <div class="muted">Move list</div>
        <ol id="moveList" style="max-height:220px;overflow:auto;padding-left:18px;margin:6px 0"></ol>
      </aside>
    </div>
  </div>

<script>
/* chess_single.html
   - full move generation for pieces (no castling/en-passant)
   - promotion auto->queen
   - legal-move filtering (can't move into check)
   - simple AI (random legal move)
   - last-move highlight, win popup
   - difficulty locked after start
   - right-click / devtools blocked
*/

// Emoji mapping for display
const EMOJI = { P:'♙', N:'♘', B:'♗', R:'♖', Q:'♕', K:'♔',
                p:'♟', n:'♞', b:'♝', r:'♜', q:'♛', k:'♚' };

const boardEl = document.getElementById('board');
const turnLabel = document.getElementById('turnLabel');
const statusLabel = document.getElementById('statusLabel');
const moveList = document.getElementById('moveList');
const startBtn = document.getElementById('startBtn');
const difficulty = document.getElementById('difficulty');
const undoBtn = document.getElementById('undoBtn');
const resetBtn = document.getElementById('resetBtn');

let board = []; // 8x8 array with piece codes or null
let whiteToMove = true;
let selected = null; // {r,c}
let legalCache = [];
let history = []; // {board,whiteToMove,moveSAN}
let gameStarted = false;
let lastMove = null; // {from,to}
let floating = null;

// initial starting position
const START = [
  ['r','n','b','q','k','b','n','r'],
  ['p','p','p','p','p','p','p','p'],
  [null,null,null,null,null,null,null,null],
  [null,null,null,null,null,null,null,null],
  [null,null,null,null,null,null,null,null],
  [null,null,null,null,null,null,null,null],
  ['P','P','P','P','P','P','P','P'],
  ['R','N','B','Q','K','B','N','R']
];

// helpers
function cloneBoard(b){ return b.map(r => r.slice()); }
function inBounds(r,c){ return r>=0 && c>=0 && r<8 && c<8; }
function isWhite(p){ return p && p === p.toUpperCase(); }
function isBlack(p){ return p && p === p.toLowerCase(); }
function pieceColor(p){ if(!p) return null; return isWhite(p)?'w':'b'; }

// init / UI
function initPosition(){
  board = cloneBoard(START);
  whiteToMove = true;
  selected = null;
  legalCache = [];
  history = [];
  lastMove = null;
  gameStarted = false;
  updateTurn();
  statusLabel.textContent = 'Idle';
  moveList.innerHTML = '';
  render();
}

function render(){
  boardEl.innerHTML = '';
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const sq = document.createElement('div');
      sq.className = 'square ' + (((r+c)%2===0) ? 'light':'dark');
      sq.dataset.r = r; sq.dataset.c = c;
      // apply last-move highlight (dest)
      if(lastMove && lastMove.to.r===r && lastMove.to.c===c) sq.classList.add('last-move');
      const p = board[r][c];
      if(p){
        const el = document.createElement('div');
        el.textContent = EMOJI[p] || p;
        el.style.pointerEvents = 'none';
        sq.appendChild(el);
      }
      sq.addEventListener('click', onSquareClick);
      boardEl.appendChild(sq);
    }
  }
  highlightLegal();
}

function updateTurn(){ turnLabel.textContent = whiteToMove ? 'White' : 'Black'; }

// --- Move generation ---
// returns array of moves: {from:{r,c}, to:{r,c}, piece, captured, promotion}
function generatePseudoMovesForSide(sideWhite){
  const moves = [];
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p = board[r][c];
      if(!p) continue;
      if(isWhite(p) !== sideWhite) continue;
      genMovesForPiece(r,c,p,moves);
    }
  }
  return moves;
}

function genMovesForPiece(r,c,p,moves){
  const color = isWhite(p)?'w':'b';
  const enemyTest = isWhite(p) ? isBlack : isWhite;
  // pawn
  if(p.toUpperCase()==='P'){
    const dir = isWhite(p) ? -1 : 1;
    const fr = r + dir;
    if(inBounds(fr,c) && !board[fr][c]) pushPawnMove(r,c,fr,c,p,moves);
    // double
    const startRow = isWhite(p)?6:1;
    const fr2 = r + dir*2;
    if(r===startRow && inBounds(fr2,c) && !board[fr][c] && !board[fr2][c]) pushPawnMove(r,c,fr2,c,p,moves);
    // captures
    for(const dc of [-1,1]){
      const cc = c+dc;
      if(inBounds(fr,cc) && board[fr][cc] && enemyTest(board[fr][cc])) pushPawnMove(r,c,fr,cc,p,moves,board[fr][cc]);
    }
    return;
  }

  if(p.toUpperCase()==='N'){
    const steps = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
    for(const s of steps){
      const rr=r+s[0], cc=c+s[1];
      if(!inBounds(rr,cc)) continue;
      if(!board[rr][cc] || pieceColor(board[rr][cc])!==color) moves.push({from:{r,c},to:{r:rr,c:cc},piece:p,captured:board[rr][cc]||null});
    }
    return;
  }

  if(p.toUpperCase()==='B' || p.toUpperCase()==='R' || p.toUpperCase()==='Q'){
    const dirs = [];
    if(p.toUpperCase()==='B' || p.toUpperCase()==='Q') dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
    if(p.toUpperCase()==='R' || p.toUpperCase()==='Q') dirs.push([-1,0],[1,0],[0,-1],[0,1]);
    for(const d of dirs){
      let rr=r+d[0], cc=c+d[1];
      while(inBounds(rr,cc)){
        if(!board[rr][cc]) moves.push({from:{r,c},to:{r:rr,c:cc},piece:p,captured:null});
        else { if(pieceColor(board[rr][cc])!==color) moves.push({from:{r,c},to:{r:rr,c:cc},piece:p,captured:board[rr][cc]}); break; }
        rr += d[0]; cc += d[1];
      }
    }
    return;
  }

  if(p.toUpperCase()==='K'){
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      if(dr===0 && dc===0) continue;
      const rr=r+dr, cc=c+dc;
      if(!inBounds(rr,cc)) continue;
      if(!board[rr][cc] || pieceColor(board[rr][cc])!==pieceColor(p)) moves.push({from:{r,c},to:{r:rr,c:cc},piece:p,captured:board[rr][cc]||null});
    }
    return;
  }
}

function pushPawnMove(fr,fc,tr,tc,p,moves,captured=null){
  // promotion?
  const promotionRank = isWhite(p) ? 0 : 7;
  if(tr === promotionRank){
    moves.push({from:{r:fr,c:fc},to:{r:tr,c:tc},piece:p,captured:captured,promotion:'Q'});
  } else {
    moves.push({from:{r:fr,c:fc},to:{r:tr,c:tc},piece:p,captured:captured||null});
  }
}

// Apply move to a board copy
function applyMoveToBoard(bd, move){
  const p = bd[move.from.r][move.from.c];
  bd[move.to.r][move.to.c] = move.promotion ? (isWhite(p)?'Q':'q') : p;
  bd[move.from.r][move.from.c] = null;
}

// Check if side's king is in check on board bd
function isKingInCheck(bd, whiteSide){
  let kr=-1,kc=-1;
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p = bd[r][c];
    if(!p) continue;
    if(whiteSide && p==='K'){ kr=r; kc=c; }
    if(!whiteSide && p==='k'){ kr=r; kc=c; }
  }
  if(kr===-1) return true;
  // scan enemy pieces to see if they attack king
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p = bd[r][c];
    if(!p) continue;
    if(whiteSide && isWhite(p)) continue;
    if(!whiteSide && isBlack(p)) continue;
    const attacks = pseudoAttacks(bd, r, c);
    for(const a of attacks) if(a.r===kr && a.c===kc) return true;
  }
  return false;
}

// pseudo-attacks (where piece can capture), used for check detection
function pseudoAttacks(bd, r, c){
  const p = bd[r][c];
  if(!p) return [];
  const res = [];
  const colorWhite = isWhite(p);
  if(p.toUpperCase()==='P'){
    const dir = colorWhite ? -1 : 1;
    for(const dc of [-1,1]){
      const rr=r+dir, cc=c+dc;
      if(inBounds(rr,cc)) res.push({r:rr,c:cc});
    }
    return res;
  }
  if(p.toUpperCase()==='N'){
    const steps = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
    for(const s of steps){ const rr=r+s[0], cc=c+s[1]; if(inBounds(rr,cc)) res.push({r:rr,c:cc}); }
    return res;
  }
  if(p.toUpperCase()==='B' || p.toUpperCase()==='R' || p.toUpperCase()==='Q'){
    const dirs=[];
    if(p.toUpperCase()==='B' || p.toUpperCase()==='Q') dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
    if(p.toUpperCase()==='R' || p.toUpperCase()==='Q') dirs.push([-1,0],[1,0],[0,-1],[0,1]);
    for(const d of dirs){
      let rr=r+d[0], cc=c+d[1];
      while(inBounds(rr,cc)){
        res.push({r:rr,c:cc});
        if(bd[rr][cc]) break;
        rr+=d[0]; cc+=d[1];
      }
    }
    return res;
  }
  if(p.toUpperCase()==='K'){
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0 && dc===0) continue; const rr=r+dr, cc=c+dc; if(inBounds(rr,cc)) res.push({r:rr,c:cc}); }
    return res;
  }
  return res;
}

// produce fully legal moves for current side (filters moves that leave king in check)
function legalMovesForSide(whiteSide){
  const pseudo = generatePseudoMovesForSide(whiteSide);
  const legal = [];
  for(const m of pseudo){
    const bd = cloneBoard(board);
    applyMoveToBoard(bd,m);
    if(!isKingInCheck(bd, whiteSide)) legal.push(m);
  }
  return legal;
}

// --- UI handlers ---
function onSquareClick(e){
  const r = +this.dataset.r, c = +this.dataset.c;
  if(!gameStarted) return;
  const p = board[r][c];
  if(selected){
    // check if destination is legal for selected
    const legal = legalMovesForSide(whiteToMove).filter(m => m.from.r===selected.r && m.from.c===selected.c);
    const found = legal.find(m => m.to.r===r && m.to.c===c);
    if(found){
      performAnimatedMove(found);
      selected = null;
      clearHighlights();
      return;
    }
    // otherwise, if clicked own piece, change selection
    if(p && isWhite(p)===whiteToMove){
      selected = {r,c};
      clearHighlights();
      highlightLegal();
      return;
    }
    // else clear selection
    selected = null; clearHighlights(); return;
  } else {
    if(p && isWhite(p)===whiteToMove){
      selected = {r,c};
      highlightLegal();
    }
  }
}

function highlightLegal(){
  clearHighlights();
  if(!selected) return;
  const squares = Array.from(boardEl.children);
  const legal = legalMovesForSide(whiteToMove).filter(m => m.from.r===selected.r && m.from.c===selected.c);
  // highlight source
  const srcIdx = selected.r*8 + selected.c;
  squares[srcIdx].classList.add('highlight');
  for(const m of legal){
    const idx = m.to.r*8 + m.to.c;
    squares[idx].classList.add('highlight');
  }
}

function clearHighlights(){
  Array.from(boardEl.children).forEach(sq => sq.classList.remove('highlight'));
}

// animate piece move then apply to model
function performAnimatedMove(move){
  const fromIdx = move.from.r*8 + move.from.c, toIdx = move.to.r*8 + move.to.c;
  const srcEl = boardEl.children[fromIdx];
  const dstEl = boardEl.children[toIdx];
  const piece = board[move.from.r][move.from.c];
  if(!srcEl) { applyMoveAndContinue(move); return; }

  // create floating element
  const floatEl = document.createElement('div');
  floatEl.className = 'floating-piece';
  floatEl.textContent = EMOJI[piece] || piece;
  document.body.appendChild(floatEl);

  const sRect = srcEl.getBoundingClientRect();
  const dRect = dstEl.getBoundingClientRect();
  // center offsets
  const startLeft = sRect.left + sRect.width/2 - 14;
  const startTop  = sRect.top  + sRect.height/2 - 14;
  floatEl.style.left = startLeft + 'px';
  floatEl.style.top  = startTop + 'px';

  // hide source visually immediately (avoid duplicate)
  const srcText = srcEl.innerHTML;
  srcEl.innerHTML = '';

  // trigger transform to destination
  requestAnimationFrame(()=> {
    floatEl.style.left = (dRect.left + dRect.width/2 - 14) + 'px';
    floatEl.style.top  = (dRect.top  + dRect.height/2 - 14) + 'px';
    floatEl.style.transform = 'scale(1.02)';
  });

  floatEl.addEventListener('transitionend', function onEnd(){
    floatEl.removeEventListener('transitionend', onEnd);
    floatEl.remove();
    // apply model move
    applyMoveAndContinue(move);
  });

  // safety timeout (if transitionend doesn't fire)
  setTimeout(()=>{ try{ if(document.body.contains(floatEl)) { floatEl.remove(); applyMoveAndContinue(move);} }catch(e){} }, 700);
}

function applyMoveAndContinue(move){
  // save history for undo
  history.push({board: cloneBoard(board), whiteToMove, moveSAN: moveToSAN(move)});
  // apply to board model
  const p = board[move.from.r][move.from.c];
  board[move.to.r][move.to.c] = move.promotion ? (isWhite(p)?'Q':'q') : p;
  board[move.from.r][move.from.c] = null;
  // update lastMove info
  lastMove = { from: move.from, to: move.to };
  // switch side
  whiteToMove = !whiteToMove;
  legalCache = [];
  render();
  updateTurn();
  addMoveToList(move);
  // check for king capture / checkmate/stalemate
  postMoveChecks();
}

function moveToSAN(move){
  const pieceChar = move.piece.toUpperCase()==='P' ? '' : move.piece.toUpperCase();
  const capture = move.captured ? 'x' : '';
  return `${pieceChar}${capture}${String.fromCharCode(97+move.to.c)}${8-move.to.r}`;
}

function addMoveToList(move){
  const li = document.createElement('li');
  li.textContent = moveToSAN(move);
  moveList.appendChild(li);
}

// after a model move, check for win or call AI
function postMoveChecks(){
  // check king existence
  let whiteKing=false, blackKing=false;
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    if(board[r][c]==='K') whiteKing=true;
    if(board[r][c]==='k') blackKing=true;
  }
  if(!whiteKing || !blackKing){
    const winner = !whiteKing ? 'Black' : 'White';
    showPopup(`${winner} wins!`);
    gameStarted = false;
    return;
  }

  // check legal moves for side to move
  const legal = legalMovesForSide(whiteToMove);
  if(legal.length===0){
    if(isKingInCheck(board, whiteToMove)){
      const winner = whiteToMove ? 'Black' : 'White';
      showPopup(`Checkmate — ${winner} wins!`);
    } else {
      showPopup('Stalemate — Draw');
    }
    gameStarted = false;
    return;
  }

  // if AI to play (we always let human be White in this single-player page)
  // AI plays black when whiteToMove === false
  if(gameStarted && !whiteToMove){
    setTimeout(()=> aiPlay(), 300 + (100 * (3 - Number(difficulty.value))),  ); // small delay depending on difficulty
  }
}

// AI: pick random legal move (good baseline)
function aiPlay(){
  const legal = legalMovesForSide(whiteToMove); // whiteToMove === false for AI
  if(legal.length===0) return;
  // difficulty influences randomness: hard -> pick highest-eval among sample, easy -> random
  const diff = Number(difficulty.value);
  if(diff <= 1){
    const m = legal[Math.floor(Math.random() * legal.length)];
    performAnimatedMove(m);
    return;
  }
  // medium/hard: sample some moves and pick best by simple material eval
  const sampleSize = diff===2 ? Math.min(legal.length, 6) : Math.min(legal.length, 14);
  shuffleArray(legal);
  const sample = legal.slice(0, sampleSize);
  let best = sample[0], bestScore = -Infinity;
  for(const m of sample){
    const bd = cloneBoard(board);
    applyMoveToBoard(bd,m);
    const s = evaluateBoard(bd);
    if(s > bestScore){ bestScore = s; best = m; }
  }
  performAnimatedMove(best);
}

function shuffleArray(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
}

// very simple material evaluator (AI uses it)
function evaluateBoard(bd){
  const val = { 'P':100,'N':320,'B':330,'R':500,'Q':900,'K':20000,
                'p':-100,'n':-320,'b':-330,'r':-500,'q':-900,'k':-20000 };
  let s=0;
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p = bd[r][c];
    if(p) s += (val[p]||0);
  }
  return s * (whiteToMove ? -1 : 1); // prefer moves good for AI side
}

// check for check/checkmate after move already applied handled in postMoveChecks()

// undo / reset
undoBtn.addEventListener('click', ()=> {
  if(history.length===0) return;
  const last = history.pop();
  board = cloneBoard(last.board);
  whiteToMove = last.whiteToMove;
  legalCache = [];
  gameStarted = true;
  render();
  updateTurn();
});
resetBtn.addEventListener('click', ()=> {
  initPosition();
});

// game start
startBtn.addEventListener('click', ()=> {
  initPosition();
  gameStarted = true;
  difficulty.disabled = true;
  statusLabel.textContent = 'Your move (White)';
});

// small helpers
function updateTurn(){ turnLabel.textContent = whiteToMove ? 'White' : 'Black'; }

// popup
function showPopup(html){
  const root = document.createElement('div');
  root.className = 'popup';
  root.innerHTML = `<div class="panel"><h3>${html}</h3><div style="margin-top:12px"><button id="closePop" class="btn-primary">OK</button></div></div>`;
  document.body.appendChild(root);
  document.getElementById('closePop').addEventListener('click', ()=> { root.remove(); difficulty.disabled = false; });
}

// block right-click and devtools shortcuts
document.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener('keydown', e => {
  if(e.keyCode === 123 || (e.ctrlKey && e.shiftKey && (e.keyCode === 73 || e.keyCode === 74)) || (e.ctrlKey && e.keyCode === 85)) {
    e.preventDefault();
  }
});

// Initialize UI
initPosition();
</script>
</body>
</html>
